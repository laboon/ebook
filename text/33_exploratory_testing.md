# Exploratory Testing

We've determined how to understand requirements, develop a test plan, and find defects in a variety of different ways.  There has been an underlying assumption for everything we have done so far - that we know what the behavior of the program is supposed to be, or at least that somebody does.  Sometimes, especially at the beginning of development before ideas and software have fully crystallized, nobody may know what should happen under specific circumstances.  These may be input values that no systems engineer thought about, or the software being used for a different purpose than intended, or usability aspects that were not considered when the system was being designed.  Situations may also arise where there is no time in the schedule for a formal test plan, or for the kind of software being developed, it is seen as unnecessary.  Finally, testers may want to check out parts of the system in order to understand them, and find defects only incidentally.

Under such circumstances, you will want to use __exploratory testing__.  This is defined as testing without a specified test plan, where the main goal is to learn about and influence the development of the system, as opposed to specifically determining whether the observed behavior is equal to the expected behavior.  Exploratory testing allows the tester to follow his or her own path, thinking of edge cases on the fly or following leads if something seems like it may cause a problem.  It also allows the tester to learn by doing, instead of reading design documentation or code, which is often a much more effective way to understand a system.

## Concepts, Benefits, and Drawbacks

Exploratory testing is sometimes referred to as "_ad hoc_" testing, but that term can imply carelessness and sloppy work.  However, exploratory testing isn't careless, it's just less rigid.  There is often much thought put into determining whether exploratory testing is appropriate and even more thought put into determining the next things to explore.

Exploratory testing is often the first experience a tester may have with a new feature or system.  Step-by-step instructions - to be added as execution steps to a test plan - may not be determinable only by reading design documents.  Often, some initial exploratory testing is done to understand how things have been implemented.  As a tester gains experience with the system, there may be even more exploratory testing, as they better understand the nooks and crannies which were not covered by their initial test plan.  Occasionally, there's just nothing for a tester to do, and so they spend some time hunting for defects off the beaten path of tests based solely on test plans!

By spending some time in the weeds - where test plans have not yet treat - a tester may discover quirks in the system that will never be caught by more formalized testing.  Additionally, exploratory testing will often uncover more defects, by operating much faster.  More time spent on testing, as opposed to the minutiae of looking up test plans, writing down test statuses, etc., means that more time is spent finding defects and fewer developing documentation around those defects.

Exploratory testing also provides a side benefit, as the tester will learn about the system more quickly than with formal testing.  Mindlessly following a test plan does not allow for much of the back-and-forth that characterizes learning in humans.  Just as you will find it difficult to learn to play the piano simply by reading a book, you will find it more difficult to understand the system under test by simply reading and executing test plans.

There is very little overhead involved in installing the software or accessing the system and just trying to find defects, unlike the steps involved in developing and writing out a test plan and executing it.  If you have half an hour to find as many bugs as possible in some software, you aren't going to spend the first twenty-five minutes writing up preconditions and postconditions and execution steps, only to run a few tests at the end.  This also means that it's very easy to run an updated test, even if the software has been dramatically modified; simply do some more exploratory testing!  There's no test plans to update aside from the one in the tester's head, whereas a test plan (or even worse yet, an automated test) might require much modification to work whenever the original program is changed.

There are some downsides to exploratory testing, of course.  After all, there is a reason that test plans are developed in the first place.  The first downside is that it is unregulated, meaning that there is no real plan ahead of time to determine what to test.  Trying to explain to non-testers exactly what is going to be tested and why can be difficult, and even trying to explain retroactively may not be the easiest thing in the world.  While deep in testing some software, you may have a perfect mental model of what you are doing and the reasons behind it, but this is often lost once you finished.

Much of the responsibility for what exactly to test will be in the hands of the tester when doing exploratory testing.  A diligent tester who understands the system well will do a much better job of discovering defects than a tester who does not understand the system or is lazy.  If the testers were both following the same test plan, then assuming that the second tester is at least diligent enough to do the tests and write down the correct results, then the amount of coverage will be well-known and approximately equal for them both.  Providing a formalized testing plan thus often hinders experienced testers while helping inexperienced testers, who may be at a loss of what to test without guidance.

Another problem that may arise when doing exploratory testing is that the defects may found may not be reproducible.  It could be that the reason something failed ten minutes into an exploratory test is because the tester did something slightly different than the last time in the first minute of testing.  Trying to repeat all of the steps without knowing what the difference was can be an exercise in frustration, if not actually impossible.  With formalized testing, assuming that the tester has followed the steps, this is much less of a problem.

It's difficult to gauge how much coverage the system under test has received when using exploratory testing.  Unless the tester is recording exactly what is being done, via screen capture software, software logging, or manually, there may be many parts of the system where you're not sure how well-tested it is.  There is very little do analyze since there are so few test artifacts.  If you are working in a safety-critical domain, or one in which there is the necessity of documenting what has been tested, relying on exploratory testing will not serve you well.

Testing as a field has relied more and more upon automation as time goes on, and there's been no signs of that slowing down.  However, since exploratory testing relies so much on the skill of the tester and their familiarity with the system under test, it's basically impossible at this point to automate it.  Barring any unforeseen advances in artificial intelligence applied to testing, you will still require human beings to do this testing.

## Guidelines for Exploratory Testing

Here are the two simple steps for exploratory testing:

1. Use your best judgment.
2. If in doubt about what to do, see step 1.

Exploratory testing assumes that you as a tester understand the system, or at least are understanding the system better as time goes on.  After all, if you are writing a test plan before you test a feature, by definition that's the time that you'll be the least knowledgeable about that system.  You will learn more and more as time goes on and you interact with the system more.  It also assumes that you will be able to recognize a defect even if it you are not doing a strict matching of observed behavior against expected behavior.  This means that there should be more frequent communication with engineers, system designers, and others to determine whether or not a given behavior is, in fact, expected.

How does one go about performing exploratory testing?  This is going to depend on the particular system under test, but some broad guidelines can be given.  The first guideline is to check that frequently used and important tasks can be completed and behave correctly.  It matters little if the system handles a strange corner case if none of the simple base cases work!  Check the happy path and make sure that it works correctly before heading off into the unhappy weeds.

Once you have determined that key basic functionality is operating correctly, think of edge cases as you go along.  If asked to enter a number, what happens if the number is negative, or you don't enter anything, or you enter a series of control-character sequences?  If you should enter the name of the file, what happens if that file doesn't exist, or is improperly formatted?  If you don't have an idea of where things can go wrong, review the chapter __Tips for Breaking Software__ and see if any of the errors listed are possible to reproduce in your system.

Check what happens when different functionality interoperates.  If the system under test has the capability to read in a file, perform some operations on it, and save the result to disk, what happens if you try to overwrite the result to the original file?  What happens if one part of the system has a setting for "Sort Ascending" and another has it set for "Sort Descending" - do these conflicting sort orders show up as problems elsewhere?  If a system is performing a complicated rendering while also attempting to download data from the network, can race conditions occur?

Put yourself in the developer's shoes.  Even if you are not a programmer yourself, you can imagine what kinds of scenarios may not have been thought of by somebody who was focused solely on a specific feature and getting a particular method working correctly, with a project manager constantly asking for status updates.  Under such situations, many things may slip through the cracks.  The developer may not have checked for null pointers, or integer overflow, or what would happen if threads never end.  Using this knowledge, you can try to reproduce such situations from the user side, by entering in zero-length strings, or using extremely large numbers that would overflow a 32-bit integer, or attempt to read very large pieces of data from the database.

Don't be afraid to follow your intuition.  If you notice something that seems a little off, or funny, or unexpected, then you may want to try other ways to cause it and see if there is something that relates them.  You may also have ideas which would not come to you if you were just developing a test plan.  This is the time to try things out!

Finally, even though exploratory testing is a much less formal process than generating and executing test plans, you will want to write down defects that you find as soon as you can, and in as detailed a manner as you can.  The longer you wait, the more details you will forget.  Additionally, if you continue using the system, the more likely it will be that you may find yourself in a state where it's impossible to reproduce the error.  Determining the steps which caused the defect and writing them down should override trying to find more defects.  After all, if you don't note what the defects are and provide enough information for a developer to fix them, then there really is no point to doing testing at all.  You can also use the reproduction steps you've determined to perhaps add a more formal test for later.
